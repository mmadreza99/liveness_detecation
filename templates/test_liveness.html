<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Liveness Detection</title>
  <style>
    body {
      font-family: Tahoma, Arial, sans-serif;
      text-align: center;
      margin: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 { color: #2c3e50; margin-bottom: 20px; }
    video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #3498db;
      border-radius: 8px;
      display: block;
      margin: 10px auto;
    }
    button {
      padding: 12px 25px;
      margin: 10px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    #startBtn { background: #27ae60; color: white; }
    #startBtn:hover { background: #219a52; }
    #resetBtn { background: #e74c3c; color: white; }
    #resetBtn:hover { background: #c0392b; }
    button:disabled { background: #bdc3c7; cursor: not-allowed; }
    .status-item {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      padding: 8px;
      background: #f1f8ff;
      border-radius: 5px;
    }
    .status-label { font-weight: bold; color: #2c3e50; }
    .status-value { color: #34495e; }
    #instruction {
      font-size: 18px;
      margin: 20px;
      color: #e74c3c;
      font-weight: bold;
      min-height: 30px;
    }
    #countdown {
      font-size: 24px;
      font-weight: bold;
      color: #e74c3c;
      margin: 15px 0;
    }
    .result {
      margin: 15px 0;
      padding: 15px;
      border-radius: 5px;
      font-weight: bold;
    }
    .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .processing { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª (Liveness Detection)</h1>

    <div class="status-item">
      <span class="status-label">ÙˆØ¶Ø¹ÛŒØª Ø¯ÙˆØ±Ø¨ÛŒÙ†:</span>
      <span class="status-value" id="cameraStatus">ØºÛŒØ±ÙØ¹Ø§Ù„</span>
    </div>

    <div class="status-item">
      <span class="status-label">Ø§ÛŒÙ† Ù…ØªÙ† Ø±Ø§ Ø¨Ø§ ØµØ¯Ø§ÛŒ Ø¨Ù„Ù†Ø¯ Ø¨Ø®ÙˆØ§Ù†ÛŒØ¯:</span>
      <span class="status-value" id="readingText">***</span>
    </div>

    <video id="video" autoplay playsinline></video>

    <div class="status-item">
      <span class="status-label">Ø²Ø¨Ø§Ù† Ú¯ÙØªØ§Ø±:</span>
      <select id="languageSelect" class="status-value">
        <option value="auto">ØªØ´Ø®ÛŒØµ Ø®ÙˆØ¯Ú©Ø§Ø±</option>
        <option value="fa" selected>ÙØ§Ø±Ø³ÛŒ ğŸ‡®ğŸ‡·</option>
        <option value="en">English ğŸ‡ºğŸ‡¸</option>
        <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ğŸ‡¸ğŸ‡¦</option>
        <option value="tr">TÃ¼rkÃ§e ğŸ‡¹ğŸ‡·</option>
      </select>
    </div>

    <div id="instruction">Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ø§ ÙØ´Ø§Ø± Ø¯Ù‡ÛŒØ¯</div>
    <div id="countdown"></div>

    <div class="status-item">
      <span class="status-label">ÙˆØ¶Ø¹ÛŒØª Ú†Ø§Ù„Ø´:</span>
      <span class="status-value" id="challengeStatus">Ø¢Ù…Ø§Ø¯Ù‡</span>
    </div>

    <div class="status-item">
      <span class="status-label">Ù¾ÛŒØ´Ø±ÙØª:</span>
      <span class="status-value" id="progressStatus">0%</span>
    </div>

    <div id="resultContainer"></div>

    <button id="startBtn">Ø´Ø±ÙˆØ¹ ØªØ´Ø®ÛŒØµ Ø²Ù†Ø¯Ù‡â€ŒØ¨ÙˆØ¯Ù†</button>
    <button id="resetBtn" disabled>Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ</button>
  </div>

<script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const languageSelect = document.getElementById('languageSelect');
    const instructionDiv = document.getElementById('instruction');
    const countdownDiv = document.getElementById('countdown');
    const resultContainer = document.getElementById('resultContainer');
    const cameraStatus = document.getElementById('cameraStatus');
    const challengeStatus = document.getElementById('challengeStatus');
    const progressStatus = document.getElementById('progressStatus');
    const readingText = document.getElementById('readingText');

    let mediaRecorder;
    let audioChunks = [];
    let currentNonce = null;
    let expiresAt = null;
    let stream;              // âœ… Shared audio+video stream
    let intervalId;
    let countdownInterval;
    let remainingTime = 10;
    const canvas = document.createElement('canvas');

    // âœ… Start webcam + microphone
    async function startWebcam() {
        try {
            cameraStatus.textContent = "Ø¯Ø± Ø­Ø§Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ...";
            stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: window.innerWidth > 600 ? 640 : 320 },
                    height: { ideal: window.innerWidth > 600 ? 480 : 240 },
                    facingMode: "user"
                },
                audio: true // Ú¯Ø±ÙØªÙ† ØµØ¯Ø§ Ùˆ ØªØµÙˆÛŒØ± Ø¨Ø§ Ù‡Ù…
            });
            video.srcObject = stream;
            video.muted = true;
            video.volume = 0;
            cameraStatus.textContent = "ÙØ¹Ø§Ù„";
            return true;
        } catch (err) {
            console.error("Error accessing webcam or mic:", err);
            cameraStatus.textContent = "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ";
            showResult("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† ÛŒØ§ Ù…ÛŒÚ©Ø±ÙˆÙÙ†. Ù„Ø·ÙØ§Ù‹ Ù…Ø¬ÙˆØ²Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.", "error");
            return false;
        }
    }

    // âœ… Stop everything
    function stopLiveness() {
        console.log('stop liveness' +countdownInterval)
        if (stream) stream.getTracks().forEach(track => track.stop());
        if (intervalId) clearInterval(intervalId);
        if (countdownInterval) clearInterval(countdownInterval);
        video.srcObject = null;
        instructionDiv.textContent = "Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ø§ ÙØ´Ø§Ø± Ø¯Ù‡ÛŒØ¯";
        countdownDiv.textContent = "";
        challengeStatus.textContent = "Ø¢Ù…Ø§Ø¯Ù‡";
        progressStatus.textContent = "0%";
        cameraStatus.textContent = "ØºÛŒØ±ÙØ¹Ø§Ù„";
        startBtn.disabled = false;
        resetBtn.disabled = true;
        fetch('/reset_attempts/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ get_instruction: true })
        });
    }

    // âœ… Countdown update
    function updateCountdown() {
        countdownDiv.textContent = `Ø²Ù…Ø§Ù† Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${remainingTime} Ø«Ø§Ù†ÛŒÙ‡`;
        remainingTime--;
        if (remainingTime < 0) {
            clearInterval(countdownInterval);
            countdownDiv.textContent = "Ø²Ù…Ø§Ù† Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯!";
        }
    }

    // âœ… Show result message
    function showResult(message, type) {
        resultContainer.innerHTML = `<div class="result ${type}">${message}</div>`;
    }

    // âœ… Fetch random instruction from server
    async function getInstruction() {
        try {
            const response = await fetch('/check_frame/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ get_instruction: true })
            });
            const data = await response.json();
            instructionDiv.textContent = data.instruction || "Ø¯Ø³ØªÙˆØ± Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª";
            currentNonce = data.nonce;
            expiresAt = new Date(data.expires);
            readingText.textContent = data.read_text || "***";
            console.log("Reading text:", data.read_text);
            return data.instruction;
        } catch (err) {
            console.error("Error fetching instruction:", err);
            instructionDiv.textContent = "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯Ø³ØªÙˆØ±";
            return null;
        }
    }

    // âœ… Send frames periodically
    function startSendingFrames() {
        let frameIndex = 0;

        intervalId = setInterval(async () => {
            if (!video.videoWidth || !video.videoHeight) return;

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            const imgData = canvas.toDataURL('image/jpeg');
            const selectedLang = languageSelect.value;

            const payload = {
                image: imgData,
                nonce: currentNonce,
                client_time: new Date().toISOString(),
                frame_index: frameIndex++,
                lang: selectedLang
            };

            try {
                const resp = await fetch('/check_frame/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const resData = await resp.json();

                if (resData.status && resData.status !== "Processing...") {
                    challengeStatus.textContent = resData.status.includes("Alive") ? "Ù…ÙˆÙÙ‚" : "Ù†Ø§Ù…ÙˆÙÙ‚";
                    if (resData.status.includes("Alive")) {
                        showResult("âœ… Ú†Ø§Ù„Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯", "success");
                        stopLiveness();
                    } else {
                        showResult("âš ï¸ Ú†Ø§Ù„Ø´ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯ØŒ Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯", "error");
                        stopLiveness();
                    }
                } else {
                    challengeStatus.textContent = "Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...";
                    showResult("Ø¯Ø± Ø­Ø§Ù„ ØªØ´Ø®ÛŒØµ Ø²Ù†Ø¯Ù‡â€ŒØ¨ÙˆØ¯Ù†... Ù„Ø·ÙØ§ Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ø¯Ù†Ø¨Ø§Ù„ Ú©Ù†ÛŒØ¯", "processing");
                }

                const progress = Math.min(100, Math.max(0, 100 - (remainingTime * 10)));
                progressStatus.textContent = `${progress}%`;

                if (resData.new_instruction) instructionDiv.textContent = resData.new_instruction;
                if (resData.instruction) instructionDiv.textContent = resData.instruction;

            } catch (err) {
                console.error("Error sending frame:", err);
                showResult("Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¯Ø§Ø¯Ù‡ Ø¨Ù‡ Ø³Ø±ÙˆØ±", "error");
            }
        }, 500, );
    }

    // âœ… Unified voice recorder using same stream
    async function startVoiceChallenge() {
        try {
            if (!stream) {
                alert("Ø§Ø³ØªØ±ÛŒÙ… ÙØ¹Ø§Ù„ Ù†ÛŒØ³ØªØŒ Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯.");
                return;
            }

            const audioTracks = stream.getAudioTracks();
            if (!audioTracks.length) {
                alert("Ù‡ÛŒÚ† Ù…Ø³ÛŒØ± ØµÙˆØªÛŒ Ø¯Ø± Ø§Ø³ØªØ±ÛŒÙ… ÛŒØ§ÙØª Ù†Ø´Ø¯.");
                return;
            }

            const audioStream = new MediaStream(audioTracks);
            mediaRecorder = new MediaRecorder(audioStream, { mimeType: "audio/webm" });
            audioChunks = [];

            mediaRecorder.addEventListener("dataavailable", e => {
                if (e.data && e.data.size > 0) audioChunks.push(e.data);
            });

            mediaRecorder.addEventListener("stop", async () => {
                const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
                const formData = new FormData();
                const selectedLang = languageSelect.value;

                formData.append("audio", audioBlob, "voice.webm");
                formData.append("lang", selectedLang);
                formData.append("nonce", currentNonce);

                try {
                    const response = await fetch("/check_voice/", {
                        method: "POST",
                        body: formData
                    });
                    const data = await response.json();
                    alert(`ØªØ´Ø§Ø¨Ù‡ ØµØ¯Ø§: ${(data.similarity * 100).toFixed(2)}Ùª`);
                    console.log("Voice similarity:", data.similarity);
                } catch (e) {
                    console.error("Error sending voice:", e);
                    alert("Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ØµØ¯Ø§ÛŒ Ø¶Ø¨Ø·â€ŒØ´Ø¯Ù‡");
                }
            });

            mediaRecorder.start();
            console.log("ğŸ¤ Recording started...");
            setTimeout(() => {
                try { mediaRecorder.stop(); } catch(e) { console.warn(e); }
            }, 4000);
        } catch (err) {
            console.error("Error in startVoiceChallenge:", err);
            alert("Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¶Ø¨Ø· ØµØ¯Ø§. Ù„Ø·ÙØ§Ù‹ Ù…Ø¬ÙˆØ² Ù…ÛŒÚ©Ø±ÙˆÙÙ† Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.");
        }
    }

    // âœ… Start button handler
    startBtn.addEventListener('click', async () => {
        startBtn.disabled = true;
        resetBtn.disabled = false;
        languageSelect.disabled = true;

        const webcamStarted = await startWebcam();
        if (!webcamStarted) {
            startBtn.disabled = false;
            return;
        }

        const instruction = await getInstruction();
        if (!instruction) {
            startBtn.disabled = false;
            return;
        }

        remainingTime = 10;
        updateCountdown();
        countdownInterval = setInterval(updateCountdown, 1000);
        startSendingFrames();
        startVoiceChallenge(); // âœ… uses same stream
    });

    // âœ… Reset button handler
    resetBtn.addEventListener('click', () => {
        stopLiveness();
        getInstruction();
        resultContainer.innerHTML = "";
        languageSelect.disabled = false;
    });
</script>


</body>
</html>
